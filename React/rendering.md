![](https://velog.velcdn.com/images/jihyun517/post/3ea97115-a919-40c2-87bb-c05d5ecb608c/image.png)

# CSR, SSR 그리고 SSG에 대해 파헤쳐보자🔥

> 프로젝트 초기에 회의 중
> 💁‍♂️ "저희 SSG를 사용해서 개발해보면 어떨까요?"
> 🙎‍ "SSR 말고 SSG요...?"
> Next로 개발하면 다 서버사이드렌더링 아냐? 라고 굳게 믿고 있던 나에게 큰 충격과 수치를 안겨준 한 마디...
> 어버버 거리고 나서 급하게 정리해보았습니다😂

<br>

## 💙 CSR (Client-Side Rendering)

CSR은 클라이언트 측에서 JavaScript를 사용하여 페이지를 동적으로 렌더링하는 방식이다. 사용자가 페이지를 요청하면 서버는 빈 HTML을 보내고, 클라이언트는 JavaScript를 사용하여 데이터를 가져와 페이지를 완성한다. 주로 React, Vue.js와 같은 프론트엔드 프레임워크와 함께 사용된다.

🔹 장점

- 사용자 경험 : 초기 로딩 후에는 클라이언트 측에서 JavaScript를 사용하여 페이지를 동적으로 업데이트할 수 있기 때문에 사용자 경험이 향상되고, 애플리케이션이 더욱 반응적이고 인터랙티브해진다.

🔹 단점

- SEO (검색 엔진 최적화) 문제 : 초기 HTML에는 페이지의 컨텐츠가 없으므로 검색 엔진 최적화에 문제가 발생할 수 있다.
- 초기 로딩 시간 : 초기에는 빈 페이지가 렌더링되고, 이후에 JavaScript가 실행되어 페이지가 완성되기 때문에 초기 로딩 시간이 길어질 수 있다.

<br>

## SSR과 SSG

앞서 말했듯, CSR 방식으로 개발할 경우 서버는 빈 HTML을 보내준다. 이에 반해 Next로 개발할 경우 브라우저에 렌더링 할 때 기본적으로 pre-redering(사전 렌더링)을 한다고 소개한다. (이는 NEXT의 default로 설정되어 있다). 여기서 넥스트는 pre-rendering 방식으로 SSR과 SSG 두 가지를 제공해주는 것이다! 간략하게 정리하면 아래와 같다.

- SSG(Static-Generation) (추천) : HTML을 빌드 타임에 각 페이지별로 생성하고 해당 페이지로 요청이 올 경우 이미 생성된 HTML 문서를 반환한다.
- SSR(Server-Side-Rendering) : 요청이 올 때 마다 해당하는 HTML 문서를 그때 그때 생성하여 반환한다.

SSR을 위해 어떠한 것도 따로 설정해주지 않았던 나는 그냥 Next에서 제공하는 기본값인 SSG를 사용하고 있었던 것...🤦‍♀️
그래서 이 두 개를 어떻게 사용하냐면! 간단히 설명하면 아래와 같다.
본 글은 CSR, SSG, SSR에 대한 설명이므로 자세한 사용법까지 언급하진 않겠다.

> **next13 버전 이전**

- SSG : `getStaticProp`s와 `getStaticPaths`를 함께 사용하여 페이지의 데이터를 미리 가져오고 경로를 미리 생성
- SSR : `getServerSideProp`s를 사용하여 요청이 있을 때마다 데이터를 가져와 페이지를 동적으로 생성

> **next13 버전~**
> next13 버전 이전에는 아예 다른 메소드를 사용해야 했다면, 13 버전 이후부터는 async/await을 사용한 fetch() API 를 통해 데이터를 가져온다! cache 옵션만 변경해주면 된다.

- SSG : `cache: "force-cache"` // 디폴트값으로 생략가능
- SSR : `cache: "no-store"`

<br>

## 💙 SSG (Static Site Generation)

SSG는 빌드 시점에 모든 페이지의 HTML을 미리 생성하여 서버에 배포하는 방식으로, 모든 페이지가 미리 생성되기 때문에 초기 로딩 시간이 매우 빠르다. 주로 Gatsby, Next.js와 같은 프레임워크와 함께 사용된다.

🔹 장점

- 초기 로딩 속도 : 빌드 시점에 모든 페이지의 HTML을 미리 생성하여 서버에 저장하기 때문에 사용자가 페이지를 요청할 때 서버는 미리 생성된 정적 HTML 파일을 제공하므로 초기 로딩 속도가 매우 빠르다.
- SEO (검색 엔진 최적화) 우수 : 모든 페이지의 HTML을 미리 생성하므로 검색 엔진이 페이지를 쉽게 인덱싱할 수 있다. 검색 엔진 최적화가 우수해지므로 검색 결과에 노출되는 페이지의 수가 증가할 수 있다.
- 성능 & 보안 : 서버 측에서 사전에 생성된 정적 파일을 제공하므로 서버에 대한 부하가 적고 보안에 우수하다. 동적 콘텐츠 생성에 따른 보안 취약점이 없습니다.

🔹 단점

- 실시간 데이터: 빌드 시점에 페이지의 HTML을 생성하기 때문에 동적으로 변경되는 콘텐츠를 처리하기 어렵다. 따라서 사용자 맞춤형 콘텐츠나 사용자 입력에 따라 다른 결과를 표시해야 하는 경우에는 SSG를 사용하기 어렵다.
- 빌드 시간 : 큰 규모의 웹 사이트나 콘텐츠가 많은 경우에는 모든 페이지의 HTML을 미리 생성하는 데 시간이 오래 걸릴 수 있다. 이로 인해 빌드 시간이 증가할 수 있으며, 빈번한 콘텐츠 업데이트가 필요한 경우에는 불편할 수 있다.

<br>

## 💙 SSR (Server-Side Rendering)

SSR은 서버 측에서 완전한 HTML 페이지를 생성하고 클라이언트에 전송하는 방식으로, 사용자가 페이지를 요청하면 서버에서 데이터를 가져와 HTML을 완전히 렌더링하여 보내준다. 주로 Next.js, Nuxt.js와 같은 프레임워크와 함께 사용된다.

🔹 장점

- 초기 로딩 속도 : 빌드 시점에 모든 페이지의 HTML을 미리 생성하여 서버에 저장하기 때문에 사용자가 페이지를 요청할 때 서버는 미리 생성된 정적 HTML 파일을 제공하므로 초기 로딩 속도가 매우 빠르다.
- SEO (검색 엔진 최적화) 우수 : 모든 페이지의 HTML을 미리 생성하므로 검색 엔진이 페이지를 쉽게 인덱싱할 수 있다. 검색 엔진 최적화가 우수해지므로 검색 결과에 노출되는 페이지의 수가 증가할 수 있다.
- 성능 & 보안 : 서버 측에서 사전에 생성된 정적 파일을 제공하므로 서버에 대한 부하가 적고 보안에 우수하다. 동적 콘텐츠 생성에 따른 보안 취약점이 없습니다.
- 사용자 정의 콘텐츠 처리 : 요청이 있을 때마다 서버에서 데이터를 가져와 페이지를 동적으로 생성하기 때문에 사용자에게 맞춤형 콘텐츠를 제공하고 사용자의 입력에 따라 다른 결과를 표시할 수 있다.

🔹 단점

- 서버 부하 증가 : SSR은 서버 측에서 HTML을 생성하므로 서버의 부하가 증가할 수 있다. 트래픽이 많은 경우 서버에 대한 부하를 관리하는 것이 어려울 수 있다.
- 캐싱이 어려움 : SSR은 요청이 있을 때마다 서버에서 데이터를 가져와 페이지를 생성하므로 캐싱이 어려울 수 있으며 캐싱을 구현하여 성능을 향상시키려면 추가적인 작업이 필요할 수 있다.

<br>

## 그래서 뭘 사용하라고?

사용자 경험을 향상시키고 싶고 SEO가 상대적으로 중요하지 않다 -> CSR
초기 로딩 속도가 중요하고 SEO가 중요하다 -> SSG
SEO가 중요하고 실시간 데이터 업데이트가 필요하다 -> SSR
